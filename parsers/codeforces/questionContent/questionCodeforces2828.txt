C. Adding Powers
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
Suppose you are performing the following algorithm. There is an array
v
1
,
v
2
,…,
v
n
filled with zeroes at start. The following operation is applied to the array several times — at
i
-th step (
0
-indexed) you can:
either choose position
pos
(
1≤pos≤n
) and increase
v
pos
by
k
i
;
or not choose any position and skip this step.
You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array
v
equal to the given array
a
(
v
j
=
a
j
for each
j
) after some step?
Input
The first line contains one integer
T
(
1≤T≤1000
) — the number of test cases. Next
2T
lines contain test cases — two lines per test case.
The first line of each test case contains two integers
n
and
k
(
1≤n≤30
,
2≤k≤100
) — the size of arrays
v
and
a
and value
k
used in the algorithm.
The second line contains
n
integers
a
1
,
a
2
,…,
a
n
(
0≤
a
i
≤
10
16
) — the array you'd like to achieve.
Output
For each test case print YES (case insensitive) if you can achieve the array
a
after some step or NO (case insensitive) otherwise.
Example
input
Copy
5
4 100
0 0 0 0
1 2
1
3 4
1 4 1
3 2
0 1 3
3 9
0 59049 810
output
Copy
YES
YES
NO
NO
YES
Note
In the first test case, you can stop the algorithm before the
0
-th step, or don't choose any position several times and stop the algorithm.
In the second test case, you can add
k
0
to
v
1
and stop the algorithm.
In the third test case, you can't make two
1
in the array
v
.
In the fifth test case, you can skip
9
0
and
9
1
, then add
9
2
and
9
3
to
v
3
, skip
9
4
and finally, add
9
5
to
v
2
.