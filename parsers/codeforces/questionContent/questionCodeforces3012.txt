E1. Контрольная сумма
ограничение по времени на тест2 секунды
ограничение по памяти на тест512 мегабайт
вводстандартный ввод
выводстандартный вывод
Данные пользователей ВКонтакте хранятся на десятках тысяч серверов. Для того, чтобы можно было определять ошибки при записи данных на диск, на диск регулярно записываются текущие контрольные суммы CRC32 (Wiki, IEEE 802-3). Благодаря этому, при чтении данных можно заново вычислить контрольную сумму и проверить, что данные и контрольная сумма записаны корректно.
Разумеется, проверки на совпадение контрольной суммы встроены в большинство сервисов ВКонтакте. Но как-то раз оказалось, что в одном сегменте данных нужно изменить значение четырех последовательных байт на новое — нужно заменить значения последовательности
a
i
,
a
i+1
,
a
i+2
,
a
i+3
на
x
0
,
x
1
,
x
2
,
x
3
. При этом, нужно чтобы значение контрольной суммы CRC32 осталось прежним. Конечно, при изменении последовательности ее контрольная сумма изменится, поэтому кроме изменения этих четырех байт на новое значение, были выбраны четыре байта
a
j
,
a
j+1
,
a
j+2
,
a
j+3
, которым можно назначить любое значение. Ваша задача выбрать им новые значения так, чтобы CRC32 данной последовательности не изменился, или определить, что это невозможно. Поскольку изменение данных — операция серьезная, перед самим изменением нужно определить, как изменится последовательность для
q
независимых тестовых случаев.
Обратите внимание, что в этой версии задачи есть всего один тест с
n=16,q=8
, который вы можете скачать по этой ссылке. Ваше решение не обязано проходить тесты из условия, и не будет на них протестировано. Если вы хотите проверить ваше решение на тестах из условия, отправляйте его в задачу E3, где первые два теста соответствуют примерам из условия.
Входные данные
В первой строке дано два целых числа
n
и
q
 — количество байт в файле и количество запросов, для которых нужно решить задачу (
8≤n≤2⋅
10
5
;
1≤q≤
10
5
).
Во второй строке дано
n
чисел
a
0
,
a
1
,…,
a
n−1
 — содержимое файла в байтах (
0≤
a
i
≤255
).
В следующих
q
строках дано по шесть чисел
i,j,
x
0
,
x
1
,
x
2
,
x
3
 — позиция
i
, начиная с которой нужно заменить четыре байта на
x
0
,
x
1
,
x
2
,
x
3
, и позиция
j
, начиная с которой можно менять четыре байта как угодно (
0≤i,j≤n−4
;
0≤
x
0
,
x
1
,
x
2
,
x
3
≤255
). Гарантируется, что отрезки
[i;i+3]
и
[j;j+3]
не пересекаются.
Выходные данные
Для каждого запроса выведите четыре целых числа
z
0
,
z
1
,
z
2
,
z
3
, на которые нужно заменить четыре байта с номерами
j,j+1,j+2,j+3
, чтобы crc32 не изменился. Обратите внимание, что все запросы независимы, и на самом деле последовательность не изменяется.
Если существует несколько решений, выведите любое, а если для данного запроса валидного решения нет, выведите No solution.
Примеры
входные данные
Copy
8 1
1 2 3 4 5 6 7 8
0 4 0 0 0 0
выходные данные
Copy
212 34 127 159
входные данные
Copy
16 3
4 5 6 7 0 0 0 0 0 0 0 85 200 47 47 0
11 0 0 0 0 0
3 12 7 0 0 0
0 11 0 0 0 0
выходные данные
Copy
0 0 0 0
200 47 47 0
0 0 0 0
Примечание
CRC32 байтовой последовательности из первого примера (1 2 3 4 5 6 7 8) равен 3fca88c5, CRC32 измененной последовательности (0 0 0 0 212 34 127 159) так же равен 3fca88c5. Стандартная утилита crc32 из большинства дистрибутивов линукса должна посчитать от них данную контрольную сумму.
CRC32 последовательности из второго примера равен ecbb4b55.