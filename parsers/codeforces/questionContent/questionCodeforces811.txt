D2. Tree Queries (Hard Version)
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
The only difference between this problem and D1 is the bound on the size of the tree.
You are given an unrooted tree with
n
vertices. There is some hidden vertex
x
in that tree that you are trying to find.
To do this, you may ask
k
queries
v
1
,
v
2
,…,
v
k
where the
v
i
are vertices in the tree. After you are finished asking all of the queries, you are given
k
numbers
d
1
,
d
2
,…,
d
k
, where
d
i
is the number of edges on the shortest path between
v
i
and
x
. Note that you know which distance corresponds to which query.
What is the minimum
k
such that there exists some queries
v
1
,
v
2
,…,
v
k
that let you always uniquely identify
x
(no matter what
x
is).
Note that you don't actually need to output these queries.
Input
Each test contains multiple test cases. The first line contains the number of test cases
t
(
1≤t≤
10
4
). Description of the test cases follows.
The first line of each test case contains a single integer
n
(
1≤n≤2⋅
10
5
)  — the number of vertices in the tree.
Each of the next
n−1
lines contains two integers
x
and
y
(
1≤x,y≤n
), meaning there is an edges between vertices
x
and
y
in the tree.
It is guaranteed that the given edges form a tree.
It is guaranteed that the sum of
n
over all test cases does not exceed
2⋅
10
5
.
Output
For each test case print a single nonnegative integer, the minimum number of queries you need, on its own line.
Example
input
Copy
3
1
2
1 2
10
2 4
2 1
5 7
3 10
8 6
6 1
1 3
4 7
9 6
output
Copy
0
1
2
Note
In the first test case, there is only one vertex, so you don't need any queries.
In the second test case, you can ask a single query about the node
1
. Then, if
x=1
, you will get
0
, otherwise you will get
1
.